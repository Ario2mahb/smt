package smt

import (
	"hash"
)

// DeepSparseMerkleSubTree is a deep Sparse Merkle subtree for working on only a few leafs.
type DeepSparseMerkleSubTree struct {
	*SparseMerkleTree
}

// NewDeepSparseMerkleSubTree creates a new deep Sparse Merkle subtree on an empty MapStore.
func NewDeepSparseMerkleSubTree(ms MapStore, hasher hash.Hash) *DeepSparseMerkleSubTree {
	smt := &SparseMerkleTree{
		th: *newTreeHasher(hasher),
		ms: ms,
	}

	return &DeepSparseMerkleSubTree{SparseMerkleTree: smt}
}

// AddBranches adds new branches to the tree.
// These branches are generated by smt.ProveForRoot, and should be verified by VerifyProof first.
// Set updateRoot to true if the current root of the tree should be updated.
func (dsmst *DeepSparseMerkleSubTree) AddBranches(proof SparseMerkleProof, key []byte, value []byte, updateRoot bool) ([]byte, error) {
	var oldLeaf, actualPath []byte
	if proof.NonMembershipLeafData != nil {
		var leafDataHash []byte
		actualPath, leafDataHash = dsmst.th.parseLeaf(proof.NonMembershipLeafData)
		oldLeaf, _ = dsmst.th.digestLeaf(actualPath, leafDataHash)
	}

	sideNodes := make([][]byte, dsmst.depth())
	for i, v := range proof.SideNodes {
		sideNodes[i] = make([]byte, dsmst.th.pathSize())
		copy(sideNodes[i], v)
	}

	newRoot, err := dsmst.updateWithSideNodes(dsmst.th.path(key), value, sideNodes, oldLeaf, actualPath)
	if err == nil && updateRoot {
		dsmst.SetRoot(newRoot)
	}
	return newRoot, err
}
