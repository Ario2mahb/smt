package smt

import (
	"errors"
	"hash"
)

type BadProofError struct{}

func (e *BadProofError) Error() string {
	return "bad proof"
}

// DeepSparseMerkleSubTree is a deep Sparse Merkle subtree for working on only a few leafs.
type DeepSparseMerkleSubTree struct {
	*SparseMerkleTree
}

// NewDeepSparseMerkleSubTree creates a new deep Sparse Merkle subtree on an empty MapStore.
func NewDeepSparseMerkleSubTree(ms MapStore, hasher hash.Hash, root []byte) *DeepSparseMerkleSubTree {
	smt := &SparseMerkleTree{
		th: *newTreeHasher(hasher),
		ms: ms,
	}

	smt.SetRoot(root)

	return &DeepSparseMerkleSubTree{SparseMerkleTree: smt}
}

// AddBranch adds a branch to the tree.
// These branches are generated by smt.ProveForRoot, and the proof must not be compact.
// If the proof is invalid, a BadProofError is returned.
func (dsmst *DeepSparseMerkleSubTree) AddBranch(proof SparseMerkleProof, key []byte, value []byte) error {
	if proof.BitMask != nil {
		return errors.New("proof must not be compact")
	}

	result, updates := verifyProofWithUpdates(proof, dsmst.Root(), key, value, dsmst.th.hasher)
	if !result {
		return &BadProofError{}
	}

	for _, update := range updates {
		err := dsmst.ms.Put(update[0], update[1])
		if err != nil {
			return err
		}
	}

	return nil
}
